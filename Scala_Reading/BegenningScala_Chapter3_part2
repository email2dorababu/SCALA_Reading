Date 9 Mar 2016

Object Orientation in Scala:   cont...
------------------------------------------------------------------------------------------------------------------
Inheritance:
------------
Scala supports single inheritance, not multiple inheritance.
A child (or derived) class can have one and only one parent (or base) class.
The sole exception is the root of the Scala class hierarchy, Any, which has no parent. 

You saw that "classes" in Scala are declared very much like Java classes, but "can also have parameters".

Vehicle class:

class Vehicle (speed : Int){
val mph :Int = speed
    def race() = println("Racing")
}
The Vehicle class takes one argument, which is the speed of the vehicle. 
This argument must be passed when creating an instance of class Vehicle, as follows: new Vehicle(100).
The class contains one method, called race.

Extending Class:
--------------
Extending from a base class in Scala is similar to extending in Java except for two restrictions: 
	i) method overriding requires the 'override' keyword, and 
	ii) only the primary constructor can pass parameters to the base constructor.

It is possible to override methods inherited from a super class in Scala as illustrated below:

Overriding methods inherited from a super class:

class Car (speed : Int) extends Vehicle(speed) {
override val mph: Int= speed
override  def race() = println("Racing Car")
}

The class Car extends Vehicle class using the keyword extends. 
The field mph and the method race needs to be overridden using the keyword override.

We will see another class Bike that extends Vehicle.

Vehicle Hierarchy:

class Vehicle (speed : Int){
val mph :Int = speed
    def race() = println("Racing")
}
class Car (speed : Int) extends Vehicle(speed) {
override val mph: Int= speed
override  def race() = println("Racing Car")

}
class Bike(speed : Int) extends Vehicle(speed) {
override val mph: Int = speed
override  def race() = println("Racing Bike")

}



>scalac vehicle.scala
	Now you can enter the REPL using the scala command and create the vehicle object as shown here:
scala> val vehicle1 = new Car(200)
	With this command, Scala creates the vehicle1 object as shown here:
vehicle1: Car = Car@19a8942
	Now you can use this vehicle1 object created by Scala to access the speed of the Car:
scala> vehicle1.mph
	Scala REPL emits the speed of the Car as shown here:
res1: Int = 200
	In the similar manner, you can execute the race method of vehicle1:
scala>vehicle1.race()
	Scala interpreter emits the output as shown here:
Racing Car
	Now you can create the Bike object and access its property and method:
scala> val vehicle2 = new Bike(100)
vehicle2: Bike = Bike@b7ad3
scala>vehicle2.mph
res4: Int = 100
scala> vehicle2.race()
Racing Bike
----------------------------------------------------------------------------------------------------------------

++++++++++
Traits:
+++++++++++

Suppose you want to add another class to your vehicle hierarchy. say Batmobile.
Batmobile can race,glide and fly.

But you cannot add glide and fly methods to the Vehicle class because in a nonfictional world, 
Car and Bike that extend Vehicle do not glide or fly.

So, in this case if you want to add Batmobile to your vehicle hierarchy, you can use a trait.

Traits are like interfaces in Java, which can also contain code.

In Scala, when a class inherits from a trait, it implements the interface of the trait, 
 and inherits all the code contained in the trait.

Below code shows flying and gliding traits.
flying and gliding traits:

trait flying {
    def fly() = println("flying")
}

trait floating gliding {
def gliding() = println("gliding")
}

Now you can create the Batmobile class that extends Vehicle class along with the flying and gliding traits, 
as shown below:

Using "with"
------------
class Batmobile(speed : Int) extends Vehicle(speed)  with flying with gliding{
override val mph: Int = speed
override  def race() = println("Racing Batmobile")
override def fly() = println("Flying Batmobile")
override def float() = println("Gliding Batmobile")

}

In Scala, traits can inherit classes. (i.e other way of classes implement trait)
The keyword extends is also used when a class inherits a trait as its parent. 


The keyword extends is also used even when the class mixes in other traits using the with keyword. 
Also, extends is used when one trait is the child of another trait or class.

You can now create a Batmobile in the REPL as illustrated here:
scala> val vehicle3 = new Batmobile(300)
vehicle3: Batmobile = Batmobile@374ed5
	Now you can access the fly method of the Batmobile shown here:
scala> vehicle3.fly()
Flying Batmobile


Now create a list of vehicles, then you can use the maxBy method provided by Scala collections library to find 
the fastest vehicle in the list.

scala> val vehicleList = List(vehicle1, vehicle2, vehicle3)
vehicleList: List[Vehicle] = List(Car@562791, Bike@e80317, Batmobile@374ed5)
scala> val fastestVehicle = vehicleList.maxBy(_.mph)
fastestVehicle: Vehicle = Batmobile@374ed5
---------------------------------------------------------------------------------------------------------------

Case Classes:
-------------
Scala has a mechanism for creating classes that have the common stuff filled in. 
Most of the time, when we define a class, we have to write the toString, hashCode, and equals methods. 
These methods are boilerplate.
Scala provides the case class mechanism for filling in these blanks, as well as support for pattern matching. 
A case class provides the same facilities as a normal class, 
but the compiler generates toString, hashCode, and equals methods (which you can override).

Case classes can be instantiated without the use of the new statement. 
By default, all the parameters in the case class’s constructor become properties on the case class.

how to create a case class:
case classStuff(name:String, age: Int)

You can create an instance of Stuff without the keyword new (you can use new if you want):
scala> vals = Stuff("David", 45)
s: Stuff = Stuff(David,45)

The case class’s to String method does the right thing:
scala> s.toString
res70:String = Stuff(David,45)

Stuff’s equals method does a "deep comparison":
scala> s == Stuff("David",45)
res72:Boolean = true
s == Stuff("David",43)
res73:Boolean = false

And the instance has properties:
scala> s.name
res74:String = David
scala> s.age
res75:Int = 45

If you want to write your own class that does the same thing as a case class does, it would look like below:

Implementing case features in a class on its own

classStuff(val name: String,valage: Int) {
overridedeftoString = "Stuff("+name+","+age+")"
overridedefhashCode= name.hashCode+ age
overridedefequals(other: AnyRef)= othermatch {
case s: Stuff=> this.name== s.name &&this.age == s.age
case _ => false
}
}

objectStuff {
defapply(name: String, age: Int) = newStuff(name,age)
defunapply(s: Stuff)= Some((s.name, s.age))
}
Case classes also come in handy for pattern matching will be expored in later chapters(6th).
-----------------------------------------------------------------------------------------------

Value Classes:
